#!/usr/bin/env python3
"""
Sync Live Google Sheets Registry to projectscope.md

Reads all sheets (Intake, Central Backlog, ProductOps, Optimization Center)
and writes structured summary under "## Live Sheets Registry" section.

Usage:
    python scripts/sync_sheets_registry.py

Output:
    Updates docs/projectscope.md with latest sheet structure
"""

import json
import logging
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, Optional

# Add parent directory to path to import app modules
sys.path.insert(0, str(Path(__file__).resolve().parent.parent))

from app.config import settings
from app.sheets.client import get_sheets_service, SheetsClient

logger = logging.getLogger(__name__)


class SheetsRegistrySync:
    """Syncs live Google Sheets structure to projectscope.md"""

    def __init__(self):
        self.service = get_sheets_service()
        self.client = SheetsClient(self.service)
        self.registry_lines: List[str] = []

    def run(self) -> str:
        """Generate complete registry markdown"""
        timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")

        self.registry_lines = [
            "## Live Sheets Registry",
            f"*Last synced: {timestamp}*",
            "",
            "This section is auto-generated by `scripts/sync_sheets_registry.py`.",
            "First 3 rows per tab: Row 1 = main header, Rows 2-3 = metadata/comments.",
            "",
        ]

        # 1. Intake Sheets
        self._sync_intake_sheets()

        # 2. Central Backlog Sheet(s)
        self._sync_central_backlog_sheets()

        # 3. ProductOps Sheet
        self._sync_productops_sheet()

        # 4. Optimization Center Sheet
        self._sync_optimization_center_sheet()

        return "\n".join(self.registry_lines)

    def _sync_intake_sheets(self):
        """Sync all intake sheets from intake_sheets_test_config.json"""
        self.registry_lines.append("### Intake Sheets")
        self.registry_lines.append("")

        config_file = Path("intake_sheets_test_config.json")
        if not config_file.exists():
            self.registry_lines.append("*Config file not found: intake_sheets_test_config.json*")
            self.registry_lines.append("")
            return

        with open(config_file) as f:
            intake_configs = json.load(f)

        for sheet_config in intake_configs:
            sheet_key = sheet_config.get("sheet_key", "unknown")
            spreadsheet_id = sheet_config.get("spreadsheet_id", "")
            region = sheet_config.get("region", "N/A")
            description = sheet_config.get("description", "")

            self.registry_lines.append(f"#### Intake Sheet: {sheet_key}")
            self.registry_lines.append(f"- **Spreadsheet ID**: `{spreadsheet_id}`")
            self.registry_lines.append(f"- **Region**: {region}")
            if description:
                self.registry_lines.append(f"- **Description**: {description}")
            self.registry_lines.append("")

            # Auto-discover ALL tabs in the sheet (not just ones in config)
            try:
                response = self.service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
                all_tabs = [sheet['properties']['title'] for sheet in response.get('sheets', [])]
            except Exception as e:
                self.registry_lines.append(f"  *Error reading sheet metadata: {e}*")
                self.registry_lines.append("")
                continue

            # Build a lookup of tab configs for metadata
            tab_config_lookup = {tc.get("tab_name"): tc for tc in sheet_config.get("tabs", [])}

            for tab_name in all_tabs:
                # Get metadata from config if available
                tab_config = tab_config_lookup.get(tab_name, {})
                dept = tab_config.get("department", "N/A")
                active = tab_config.get("active", None)

                self.registry_lines.append(f"##### Tab: `{tab_name}`")
                self.registry_lines.append(f"- **Department**: {dept}")
                if active is not None:
                    self.registry_lines.append(f"- **Active**: {active}")

                # Read first 3 rows
                self._read_and_append_rows(spreadsheet_id, tab_name, 3)
                self.registry_lines.append("")

    def _sync_central_backlog_sheets(self):
        """Sync central backlog sheet(s) from settings"""
        self.registry_lines.append("### Central Backlog Sheet(s)")
        self.registry_lines.append("")

        backlog_configs: List[Dict[str, Any]] = []

        # Check settings.CENTRAL_BACKLOG
        if settings.CENTRAL_BACKLOG:
            backlog_configs.append({
                "spreadsheet_id": settings.CENTRAL_BACKLOG.spreadsheet_id,
                "tab_name": settings.CENTRAL_BACKLOG.tab_name,
                "product_org": settings.CENTRAL_BACKLOG.product_org or "Default",
            })

        # Check settings.CENTRAL_BACKLOG_SHEETS
        for cfg in settings.CENTRAL_BACKLOG_SHEETS:
            backlog_configs.append({
                "spreadsheet_id": cfg.spreadsheet_id,
                "tab_name": cfg.tab_name,
                "product_org": cfg.product_org or "Default",
            })

        if not backlog_configs:
            self.registry_lines.append("*No central backlog sheets configured in .env*")
            self.registry_lines.append("")
            return

        for idx, cfg in enumerate(backlog_configs):
            org_label = cfg["product_org"]
            spreadsheet_id = cfg["spreadsheet_id"]
            configured_tab_name = cfg["tab_name"]

            self.registry_lines.append(f"#### Central Backlog: {org_label}")
            self.registry_lines.append(f"- **Spreadsheet ID**: `{spreadsheet_id}`")
            self.registry_lines.append("")

            # Auto-discover ALL tabs in the sheet
            try:
                response = self.service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
                all_tabs = [sheet['properties']['title'] for sheet in response.get('sheets', [])]
            except Exception as e:
                self.registry_lines.append(f"  *Error reading sheet metadata: {e}*")
                self.registry_lines.append("")
                continue

            for tab_name in all_tabs:
                # Mark the configured tab as primary
                if tab_name == configured_tab_name:
                    self.registry_lines.append(f"##### Tab: `{tab_name}` (Primary)")
                else:
                    self.registry_lines.append(f"##### Tab: `{tab_name}`")
                
                # Read first 3 rows
                self._read_and_append_rows(spreadsheet_id, tab_name, 3)
                self.registry_lines.append("")

    def _sync_productops_sheet(self):
        """Sync ProductOps sheet from product_ops_config.json"""
        self.registry_lines.append("### ProductOps Sheet")
        self.registry_lines.append("")

        config_file = Path("product_ops_config.json")
        if not config_file.exists():
            self.registry_lines.append("*Config file not found: product_ops_config.json*")
            self.registry_lines.append("")
            return

        with open(config_file) as f:
            po_config = json.load(f)

        spreadsheet_id = po_config.get("spreadsheet_id", "")
        self.registry_lines.append(f"- **Spreadsheet ID**: `{spreadsheet_id}`")
        self.registry_lines.append("")

        # Auto-discover ALL tabs in the sheet
        try:
            response = self.service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
            all_tabs = [sheet['properties']['title'] for sheet in response.get('sheets', [])]
        except Exception as e:
            self.registry_lines.append(f"*Error reading sheet metadata: {e}*")
            self.registry_lines.append("")
            return

        # Build display name lookup from config
        tab_display_names = {
            po_config.get("scoring_inputs_tab"): "Scoring Inputs",
            po_config.get("mathmodels_tab"): "Math Models",
            po_config.get("params_tab"): "Parameters",
            po_config.get("metrics_config_tab"): "Metrics Config",
            po_config.get("kpi_contributions_tab"): "KPI Contributions",
            po_config.get("config_tab"): "Config",
        }

        for tab_name in all_tabs:
            display_name = tab_display_names.get(tab_name, tab_name)
            self.registry_lines.append(f"#### Tab: `{tab_name}` ({display_name})")
            self._read_and_append_rows(spreadsheet_id, tab_name, 3)
            self.registry_lines.append("")

    def _sync_optimization_center_sheet(self):
        """Sync Optimization Center sheet from optimization_center_sheet_config.json"""
        self.registry_lines.append("### Optimization Center Sheet")
        self.registry_lines.append("")

        config_file = Path("optimization_center_sheet_config.json")
        if not config_file.exists():
            self.registry_lines.append("*Config file not found: optimization_center_sheet_config.json*")
            self.registry_lines.append("")
            return

        with open(config_file) as f:
            oc_config = json.load(f)

        spreadsheet_id = oc_config.get("spreadsheet_id", "")
        self.registry_lines.append(f"- **Spreadsheet ID**: `{spreadsheet_id}`")
        self.registry_lines.append("")

        # Auto-discover ALL tabs in the sheet
        try:
            response = self.service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
            all_tabs = [sheet['properties']['title'] for sheet in response.get('sheets', [])]
        except Exception as e:
            self.registry_lines.append(f"*Error reading sheet metadata: {e}*")
            self.registry_lines.append("")
            return

        # Build display name lookup from config
        tab_display_names = {
            oc_config.get("scenarios_tab"): "Scenarios",
            oc_config.get("constraint_sets_tab"): "Constraint Sets",
            oc_config.get("caps_tab"): "Caps",
            oc_config.get("floors_tab"): "Floors",
            oc_config.get("targets_tab"): "Targets",
            oc_config.get("mandatory_tab"): "Mandatory",
            oc_config.get("exclusions_initiatives_tab"): "Exclusions (Initiatives)",
            oc_config.get("exclusions_pairs_tab"): "Exclusions (Pairs)",
            oc_config.get("prerequisites_tab"): "Prerequisites",
            oc_config.get("bundles_tab"): "Bundles",
            oc_config.get("results_tab"): "Results",
            oc_config.get("runs_tab"): "Runs",
        }

        for tab_name in all_tabs:
            display_name = tab_display_names.get(tab_name, tab_name)
            self.registry_lines.append(f"#### Tab: `{tab_name}` ({display_name})")
            self._read_and_append_rows(spreadsheet_id, tab_name, 3)
            self.registry_lines.append("")

    def _read_and_append_rows(self, spreadsheet_id: str, tab_name: str, num_rows: int = 3):
        """Read first N rows from a tab and append to registry (structured by columns)"""
        try:
            range_str = f"'{tab_name}'!1:{num_rows}"  # Read entire rows, no column limit
            rows = self.client.get_values(
                spreadsheet_id=spreadsheet_id,
                range_=range_str,
                value_render_option="FORMATTED_VALUE"
            )

            if not rows:
                self.registry_lines.append("  - *No data found*")
                return

            # Transpose: convert rows to columns
            # Find max column count
            max_cols = max(len(row) for row in rows) if rows else 0
            
            if max_cols == 0:
                self.registry_lines.append("  - *No columns found*")
                return

            # Pad rows to same length
            padded_rows = []
            for row in rows:
                padded = row + [''] * (max_cols - len(row))
                padded_rows.append(padded)

            # Now output column by column
            self.registry_lines.append(f"  - **Total Columns**: {max_cols}")
            self.registry_lines.append("")

            for col_idx in range(max_cols):
                col_letter = self._get_column_letter(col_idx)
                header = padded_rows[0][col_idx] if padded_rows else ""
                
                self.registry_lines.append(f"  - **Column {col_letter}**: `{header}`")
                
                # Show all 3 rows for this column
                for row_idx in range(len(padded_rows)):
                    row_label = "Header" if row_idx == 0 else f"Meta{row_idx}"
                    value = padded_rows[row_idx][col_idx]
                    # Escape value for markdown
                    value_str = str(value).replace('|', '\\|') if value else ''
                    self.registry_lines.append(f"    - Row {row_idx + 1} ({row_label}): `{value_str}`")
                
                self.registry_lines.append("")

        except Exception as e:
            self.registry_lines.append(f"  - *Error reading tab: {e}*")
            logger.error(f"Error reading {tab_name} from {spreadsheet_id}: {e}")

    def _get_column_letter(self, col_idx: int) -> str:
        """Convert 0-based column index to Excel-style letter (A, B, ..., Z, AA, AB, ...)"""
        result = ""
        col_idx += 1  # Make it 1-based
        while col_idx > 0:
            col_idx -= 1
            result = chr(col_idx % 26 + ord('A')) + result
            col_idx //= 26
        return result


def update_projectscope_md(registry_content: str):
    """Update docs/projectscope.md with new registry section"""
    projectscope_path = Path("docs/projectscope.md")

    if not projectscope_path.exists():
        print(f"ERROR: {projectscope_path} not found")
        sys.exit(1)

    # Read existing content
    with open(projectscope_path, "r", encoding="utf-8") as f:
        content = f.read()

    # Find existing registry section (if any)
    registry_start_marker = "## Live Sheets Registry"
    registry_start_idx = content.find(registry_start_marker)

    if registry_start_idx == -1:
        # No existing section - append at end
        new_content = content.rstrip() + "\n\n" + registry_content + "\n"
    else:
        # Find next section (starts with ## at beginning of line)
        next_section_idx = content.find("\n## ", registry_start_idx + 1)

        if next_section_idx == -1:
            # Registry is last section - replace to end
            new_content = content[:registry_start_idx] + registry_content + "\n"
        else:
            # Replace section between markers
            new_content = (
                content[:registry_start_idx] +
                registry_content +
                "\n" +
                content[next_section_idx + 1:]
            )

    # Write updated content
    with open(projectscope_path, "w", encoding="utf-8") as f:
        f.write(new_content)

    print(f"✅ Updated {projectscope_path} with live sheets registry")


def main():
    """Main entry point"""
    logging.basicConfig(level=logging.INFO)

    print("Syncing live Google Sheets registry...")

    syncer = SheetsRegistrySync()
    registry_content = syncer.run()

    update_projectscope_md(registry_content)

    print("✅ Sync complete!")


if __name__ == "__main__":
    main()
