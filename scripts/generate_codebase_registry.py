#!/usr/bin/env python3
"""
Generate Exhaustive Codebase Registry to projectscope.md

Parses app/ directory using Python AST to create comprehensive registry:
- Directory structure
- All modules
- All classes with methods
- All functions with signatures

Usage:
    python scripts/generate_codebase_registry.py

Output:
    Updates docs/projectscope.md with codebase structure
"""

import ast
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Optional, Set

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).resolve().parent.parent))


class CodebaseRegistryGenerator:
    """Generates exhaustive codebase registry using AST parsing"""

    def __init__(self, root_dir: Path):
        self.root_dir = root_dir
        self.app_dir = root_dir / "app"
        self.registry_lines: List[str] = []
        self.exclude_dirs: Set[str] = {"__pycache__", ".pytest_cache", "tests", "test_scripts"}

    def run(self) -> str:
        """Generate complete codebase registry markdown"""
        timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")

        self.registry_lines = [
            "## Codebase Registry",
            f"*Auto-generated: {timestamp}*",
            "",
            "This section is auto-generated by `scripts/generate_codebase_registry.py`.",
            "Comprehensive map of `app/` directory structure, modules, classes, and functions.",
            "",
        ]

        if not self.app_dir.exists():
            self.registry_lines.append("*ERROR: app/ directory not found*")
            return "\n".join(self.registry_lines)

        # Build directory tree first
        self._build_directory_tree()

        # Parse all modules
        self._parse_all_modules()

        return "\n".join(self.registry_lines)

    def _build_directory_tree(self):
        """Build visual directory tree structure"""
        self.registry_lines.append("### Directory Structure")
        self.registry_lines.append("```")
        self.registry_lines.append("app/")
        self._tree_recursive(self.app_dir, prefix="", is_last=True)
        self.registry_lines.append("```")
        self.registry_lines.append("")

    def _tree_recursive(self, path: Path, prefix: str, is_last: bool):
        """Recursively build directory tree"""
        items = sorted(path.iterdir(), key=lambda p: (p.is_file(), p.name))
        items = [i for i in items if i.name not in self.exclude_dirs and not i.name.startswith('.')]

        for idx, item in enumerate(items):
            is_last_item = (idx == len(items) - 1)
            connector = "└── " if is_last_item else "├── "
            self.registry_lines.append(f"{prefix}{connector}{item.name}")

            if item.is_dir():
                extension = "    " if is_last_item else "│   "
                self._tree_recursive(item, prefix + extension, is_last_item)

    def _parse_all_modules(self):
        """Parse all Python modules in app/ directory"""
        self.registry_lines.append("### Modules Registry")
        self.registry_lines.append("")

        # Walk through all .py files
        py_files = sorted(self.app_dir.rglob("*.py"))
        py_files = [f for f in py_files if not any(excl in f.parts for excl in self.exclude_dirs)]

        # Group by directory
        modules_by_dir: Dict[str, List[Path]] = {}
        for py_file in py_files:
            rel_path = py_file.relative_to(self.app_dir)
            dir_path = str(rel_path.parent) if rel_path.parent != Path('.') else "app (root)"
            
            if dir_path not in modules_by_dir:
                modules_by_dir[dir_path] = []
            modules_by_dir[dir_path].append(py_file)

        # Output by directory
        for dir_path in sorted(modules_by_dir.keys()):
            if dir_path == "app (root)":
                self.registry_lines.append("#### Directory: `app/` (root)")
            else:
                self.registry_lines.append(f"#### Directory: `app/{dir_path}/`")
            self.registry_lines.append("")

            for module_file in sorted(modules_by_dir[dir_path]):
                self._parse_module(module_file)

    def _parse_module(self, module_path: Path):
        """Parse a single Python module using AST"""
        rel_path = module_path.relative_to(self.app_dir)
        module_name = module_path.stem

        self.registry_lines.append(f"##### Module: `{module_name}.py`")
        self.registry_lines.append(f"*Path*: `app/{rel_path}`")
        self.registry_lines.append("")

        try:
            with open(module_path, 'r', encoding='utf-8') as f:
                source = f.read()
            
            tree = ast.parse(source, filename=str(module_path))
            
            # Extract module-level docstring
            docstring = ast.get_docstring(tree)
            if docstring:
                # Show first line of docstring
                first_line = docstring.split('\n')[0].strip()
                self.registry_lines.append(f"*Doc*: {first_line}")
                self.registry_lines.append("")

            # Find all top-level classes and functions
            classes = []
            functions = []
            imports = []

            for node in ast.iter_child_nodes(tree):
                if isinstance(node, ast.ClassDef):
                    classes.append(node)
                elif isinstance(node, ast.FunctionDef) or isinstance(node, ast.AsyncFunctionDef):
                    functions.append(node)
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        imports.append(node.module)

            # Output imports (top 5 for context)
            if imports:
                self.registry_lines.append(f"**Imports from**: {', '.join(sorted(set(imports))[:5])}")
                self.registry_lines.append("")

            # Output classes
            if classes:
                self.registry_lines.append("**Classes**:")
                for cls in classes:
                    self._parse_class(cls)
                self.registry_lines.append("")

            # Output functions
            if functions:
                self.registry_lines.append("**Functions**:")
                for func in functions:
                    self._parse_function(func)
                self.registry_lines.append("")

            if not classes and not functions:
                self.registry_lines.append("*No classes or functions defined*")
                self.registry_lines.append("")

        except Exception as e:
            self.registry_lines.append(f"*Error parsing module: {e}*")
            self.registry_lines.append("")

    def _parse_class(self, cls_node: ast.ClassDef):
        """Parse a class definition"""
        bases = ", ".join(self._format_name(base) for base in cls_node.bases)
        base_str = f" (inherits: {bases})" if bases else ""
        
        self.registry_lines.append(f"- **Class `{cls_node.name}`**{base_str}")
        
        # Class docstring
        docstring = ast.get_docstring(cls_node)
        if docstring:
            first_line = docstring.split('\n')[0].strip()
            self.registry_lines.append(f"  - *Doc*: {first_line}")

        # Find all methods
        methods = [node for node in cls_node.body 
                   if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef))]

        if methods:
            for method in methods:
                sig = self._get_function_signature(method)
                async_prefix = "async " if isinstance(method, ast.AsyncFunctionDef) else ""
                self.registry_lines.append(f"  - `{async_prefix}{method.name}({sig})`")
        else:
            self.registry_lines.append(f"  - *No methods*")

    def _parse_function(self, func_node: ast.FunctionDef | ast.AsyncFunctionDef):
        """Parse a function definition"""
        sig = self._get_function_signature(func_node)
        return_annotation = self._format_annotation(func_node.returns) if func_node.returns else "Any"
        async_prefix = "async " if isinstance(func_node, ast.AsyncFunctionDef) else ""
        
        self.registry_lines.append(f"- **Function `{async_prefix}{func_node.name}({sig}) -> {return_annotation}`**")
        
        # Function docstring
        docstring = ast.get_docstring(func_node)
        if docstring:
            first_line = docstring.split('\n')[0].strip()
            self.registry_lines.append(f"  - *Doc*: {first_line}")

    def _get_function_signature(self, func_node: ast.FunctionDef | ast.AsyncFunctionDef) -> str:
        """Extract function signature from AST node"""
        args = func_node.args
        params = []

        # Regular args
        for arg in args.args:
            annotation = self._format_annotation(arg.annotation) if arg.annotation else ""
            param_str = f"{arg.arg}: {annotation}" if annotation else arg.arg
            params.append(param_str)

        # *args
        if args.vararg:
            annotation = self._format_annotation(args.vararg.annotation) if args.vararg.annotation else ""
            param_str = f"*{args.vararg.arg}: {annotation}" if annotation else f"*{args.vararg.arg}"
            params.append(param_str)

        # **kwargs
        if args.kwarg:
            annotation = self._format_annotation(args.kwarg.annotation) if args.kwarg.annotation else ""
            param_str = f"**{args.kwarg.arg}: {annotation}" if annotation else f"**{args.kwarg.arg}"
            params.append(param_str)

        return ", ".join(params)

    def _format_annotation(self, node: Optional[ast.expr]) -> str:
        """Format type annotation as string"""
        if node is None:
            return ""
        
        try:
            if isinstance(node, ast.Name):
                return node.id
            elif isinstance(node, ast.Constant):
                return repr(node.value)
            elif isinstance(node, ast.Subscript):
                value = self._format_annotation(node.value)
                slice_val = self._format_annotation(node.slice)
                return f"{value}[{slice_val}]"
            elif isinstance(node, ast.Tuple):
                elements = ", ".join(self._format_annotation(e) for e in node.elts)
                return f"({elements})"
            elif isinstance(node, ast.Attribute):
                return f"{self._format_name(node.value)}.{node.attr}"
            else:
                return ast.unparse(node)
        except Exception:
            return "Any"

    def _format_name(self, node: ast.expr) -> str:
        """Format a name node as string"""
        if isinstance(node, ast.Name):
            return node.id
        elif isinstance(node, ast.Attribute):
            return f"{self._format_name(node.value)}.{node.attr}"
        else:
            try:
                return ast.unparse(node)
            except Exception:
                return "?"


def update_projectscope_md(registry_content: str):
    """Update docs/projectscope.md with new codebase registry section"""
    projectscope_path = Path("docs/projectscope.md")

    if not projectscope_path.exists():
        print(f"ERROR: {projectscope_path} not found")
        sys.exit(1)

    # Read existing content
    with open(projectscope_path, "r", encoding="utf-8") as f:
        content = f.read()

    # Find existing registry section (if any)
    registry_start_marker = "## Codebase Registry"
    registry_start_idx = content.find(registry_start_marker)

    if registry_start_idx == -1:
        # No existing section - append at end
        new_content = content.rstrip() + "\n\n" + registry_content + "\n"
    else:
        # Find next section (starts with ## at beginning of line)
        next_section_idx = content.find("\n## ", registry_start_idx + 1)

        if next_section_idx == -1:
            # Registry is last section - replace to end
            new_content = content[:registry_start_idx] + registry_content + "\n"
        else:
            # Replace section between markers
            new_content = (
                content[:registry_start_idx] +
                registry_content +
                "\n" +
                content[next_section_idx + 1:]
            )

    # Write updated content
    with open(projectscope_path, "w", encoding="utf-8") as f:
        f.write(new_content)

    print(f"✅ Updated {projectscope_path} with codebase registry")


def main():
    """Main entry point"""
    print("Generating codebase registry...")

    root_dir = Path.cwd()
    generator = CodebaseRegistryGenerator(root_dir)
    registry_content = generator.run()

    update_projectscope_md(registry_content)

    print("✅ Codebase registry generation complete!")


if __name__ == "__main__":
    main()
